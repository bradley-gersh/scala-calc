package it.scalalearn.calculator

import scala.annotation.tailrec
import scala.util.Try

/**
 * Parses tokens into tree and evaluates computation
 */
object Parser {
  /**
   * Public access to Parser object
   *
   * @param  tokens a list of Tokens lexed from user input
   * @return        Try object wrapping the parse tree determined by the tokens
   */
  def apply(tokens: List[Token]): Try[ParseNode] = {
    Try(parseRoot(tokens))
  }

  /**
   * Begin and terminate parsing by recursive descent
   *
   * @param  tokens          a list of lexed Tokens
   * @return                 the parse tree determined by the tokens
   * @throws ParserException if there are leftover unparsed tokens
   * @throws ParserException if there are leftover unmatched parentheses
   */
  private def parseRoot(tokens: List[Token]): ParseNode = {
    val (leftoverTokens, tree, leftoverParens) = parseExpression(tokens, EmptyNode(), List[Token]())

    if (leftoverTokens.nonEmpty) throw new ParserException(
      s"unparsed tokens: ${leftoverTokens.foldLeft(StringBuilder())((acc, token) => acc.append(token.string))}")

    if (leftoverParens.nonEmpty) throw new ParserException(s"unmatched `(`: depth ${leftoverParens.length}")

    tree
  }

  /**
   * Parses an expression, either wrapped in parentheses or in outermost scope
   *
   * @param  tokens          tokens remaining to be parsed in this expression
   * @param  leftRootIn      if this expression is the second argument in an infix (binary) operator,
   *                         represents the node at the root of the parse tree of the first argument
   *                         (not used in this method but passed around to other methods)
   * @param  parenLevel      a List containing the as-yet unclosed parentheses at this level
   * @return                 a tuple containing:
   *                           1. a list of tokens remaining after parsing this expression
   *                           2. the root node of the parse tree generated by this expression
   *                           3. a list of the parenthesis depth after parsing this expression
   * @throws ParserException if an unmatched right parenthesis is detected
   */
  @tailrec
  private def parseExpression(tokens: List[Token],
                              leftRootIn: ParseNode,
                              parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) =
    if (tokens.isEmpty) (List(), leftRootIn, parenLevel)
    else {
      val t = tokens.head
      if (t.tokenType == TokenType.RPAREN) {
        if (parenLevel.isEmpty) throw new ParserException(s"unmatched `)`")
        else (tokens.tail, leftRootIn, parenLevel.tail)
      } else {
        val (remainingTokens, newExpr, newParenLevel) = parseTerm(tokens, EmptyNode(), parenLevel)
        if (newParenLevel.nonEmpty) parseExpression(remainingTokens, newExpr, newParenLevel)
        else (remainingTokens, newExpr, newParenLevel)
      }
    }

  /**
   * Parses a term (sum or difference) expression, including left associativity
   *
   * @param  tokens     tokens remaining to be parsed in this expression
   * @param  leftrootIn if this expression is the second argument in an infix (binary) operator,
   *                    represents the node at the root of the parse tree of the first argument
   * @param  parenLevel a List containing the as-yet unclosed parentheses at this level
   * @return            a tuple containing:
   *                      1. a list of tokens remaining after parsing this expression
   *                      2. the root node of the parse tree generated by this expression
   *                      3. a list of the parenthesis depth after parsing this expression
   */
  @tailrec
  private def parseTerm(tokens: List[Token],
                        leftRootIn: ParseNode,
                        parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) = {
    val (tokensAfterLeft, leftRoot, newParenLevelLeft) =
      if (leftRootIn.isEmpty) parseFactor(tokens, leftRootIn, parenLevel)
      else (tokens, leftRootIn, parenLevel)

    if (tokensAfterLeft.isEmpty) (tokensAfterLeft, leftRoot, newParenLevelLeft)
    else {
      val t = tokensAfterLeft.head
      if (t.tokenType == TokenType.PLUS || t.tokenType == TokenType.DASH) {
        val (tokensAfterRight, rightRoot, newParenLevelRight) =
          parseFactor(tokensAfterLeft.tail, EmptyNode(), newParenLevelLeft)
        parseTerm(tokensAfterRight, TermNode(t, leftRoot, rightRoot), newParenLevelRight)
      } else (tokensAfterLeft, leftRoot, newParenLevelLeft)
    }
  }

  /**
   * Parses a factor (product or quotient) expression, including left associativity
   *
   * @param  tokens     tokens remaining to be parsed in this expression
   * @param  leftrootIn if this expression is the second argument in an infix (binary) operator,
   *                    represents the node at the root of the parse tree of the first argument
   * @param  parenLevel a List containing the as-yet unclosed parentheses at this level
   * @return            a tuple containing:
   *                      1. a list of tokens remaining after parsing this expression
   *                      2. the root node of the parse tree generated by this expression
   *                      3. a list of the parenthesis depth after parsing this expression
   */
  @tailrec
  private def parseFactor(tokens: List[Token],
                          leftRootIn: ParseNode,
                          parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) = {
    val (tokensAfterLeft, leftRoot, newParenLevelLeft) =
      if (leftRootIn.isEmpty) parseSign(tokens, parenLevel)
      else (tokens, leftRootIn, parenLevel)

    if (tokensAfterLeft.isEmpty) (tokensAfterLeft, leftRoot, newParenLevelLeft)
    else {
      val t = tokensAfterLeft.head
      if (t.tokenType == TokenType.STAR || t.tokenType == TokenType.SLASH) {
        val (tokensAfterRight, rightRoot, newParenLevelRight) =
          parseSign(tokensAfterLeft.tail, newParenLevelLeft)
        parseFactor(tokensAfterRight, FactorNode(t, leftRoot, rightRoot), newParenLevelRight)
      } else (tokensAfterLeft, leftRoot, newParenLevelLeft)
    }
  }

  /**
   * Parses unary (sign) expression, including right associativity
   *
   * @param  tokens     tokens remaining to be parsed in this expression
   * @param  parenLevel a List containing the as-yet unclosed parentheses at this level
   * @return            a tuple containing:
   *                      1. a list of tokens remaining after parsing this expression
   *                      2. the root node of the parse tree generated by this expression
   *                      3. a list of the parenthesis depth after parsing this expression
   */
  private def parseSign(tokens: List[Token], parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) = {
    val t = tokens.head
    if (t.tokenType == TokenType.DASH) {
      val (remainingTokens, number, newParenLevel) = parseSign(tokens.tail, parenLevel)
      (remainingTokens, SignNode(t, number), newParenLevel)
    }
    else parseNumber(tokens, parenLevel)
  }

  /**
   * Parses a number token or expression into either a numeric terminal node or a nested parse tree
   *
   * @param  tokens          tokens remaining to be parsed in this expression
   * @param  parenLevel      a List containing the as-yet unclosed parentheses at this level
   * @return                 a tuple containing:
   *                           1. a list of tokens remaining after parsing this expression
   *                           2. the root node of the parse tree generated by this expression
   *                           3. a list of the parenthesis depth after parsing this expression
   * @throws ParserException if an infinite value (infinity or divide by zero) is obtained
   * @throws ParserException if an unexpected token is found where a number or parenthesized expression should be
   */
  private def parseNumber(tokens: List[Token], parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) = {
    val t = tokens.head
    if (t.tokenType == TokenType.NUMBER) {
      val value = t.string.toDouble
      if (value.isInfinite) throw new ParserException("infinite value obtained")
      else (tokens.tail, NumberNode(t.string.toDouble), parenLevel)
    }
    else if (t.tokenType == TokenType.LPAREN) {
      val (remainingTokens: List[Token], expr: ParseNode, newParenLevel) =
        parseExpression(tokens.tail, EmptyNode(), t +: parenLevel)
      (remainingTokens, expr, newParenLevel)
    }
    else throw new ParserException(s"found `${t.string}` where a number was expected")
  }
}

class ParserException(private val message: String) extends RuntimeException(message)