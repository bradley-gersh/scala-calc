package it.scalalearn.calculator

import scala.annotation.tailrec
import scala.collection.mutable
import scala.util.Try

/**
 * Parser singleton to transform tokens into a syntax tree
 */
object Parser {

  /**
   * Public access to the Parser object
   *
   * @param  tokens a list of Tokens lexed from user input
   * @return        Try object wrapping the parse tree determined by the tokens
   */
  def apply(tokens: List[Token]): Try[ParseNode] = {
    Try(parseRoot(tokens))
  }

  /**
   * Begin and terminate parsing by recursive descent
   *
   * @param  tokens          a list of lexed Tokens
   * @return                 the parse tree determined by the tokens
   * @throws ParserException if there are leftover unparsed tokens
   * @throws ParserException if there are leftover unmatched parentheses
   */
  private def parseRoot(tokens: List[Token]): ParseNode = {
    if (tokens.isEmpty) EmptyNode()
    else {
      val (leftoverTokens, tree, leftoverParens) = parseExpression(tokens, EmptyNode(), List[Token]())

      if (leftoverTokens.nonEmpty) {
        if (leftoverTokens.contains(RPAREN)) throw new ParserException("unmatched `)`")
        else throw new ParserException(
          s"unparsed tokens: ${leftoverTokens.foldLeft(mutable.StringBuilder())((acc, token) => acc.append(token.string))}")
      }

      if (leftoverParens.nonEmpty) throw new ParserException(s"unmatched `(`: depth ${leftoverParens.length}")

      tree
    }
  }

  /**
   * Parses an expression, either wrapped in parentheses or in outermost scope
   *
   * @param  tokens          tokens remaining to be parsed in this expression
   * @param  leftRootIn      if this expression is the second argument in an infix (binary) operator,
   *                         represents the node at the root of the parse tree of the first argument
   *                         (not used in this method but passed around to other methods)
   * @param  parenLevel      a List containing the as-yet unclosed parentheses at this level
   * @return                 a tuple containing:
   *                           1. a list of tokens remaining after parsing this expression
   *                           2. the root node of the parse tree generated by this expression
   *                           3. a list of the parenthesis depth after parsing this expression
   * @throws ParserException if an unmatched right parenthesis is detected
   */
  @tailrec
  private def parseExpression(tokens: List[Token],
                              leftRootIn: ParseNode,
                              parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) =
    if (tokens.isEmpty) (List(), leftRootIn, parenLevel)
    else {
      val t = tokens.head
      if (t == RPAREN) {
        if (parenLevel.isEmpty) throw new ParserException(s"unmatched `)`")
        else (tokens.tail, leftRootIn, parenLevel.tail)
      } else {
        val (remainingTokens, newExpr, newParenLevel) = parseTerm(tokens, EmptyNode(), parenLevel)
        if (newParenLevel.nonEmpty) parseExpression(remainingTokens, newExpr, newParenLevel)
        else (remainingTokens, newExpr, newParenLevel)
      }
    }

  /**
   * Parses a term (sum or difference) expression, including left associativity
   *
   * @param  tokens     tokens remaining to be parsed in this expression
   * @param  leftRootIn if this expression is the second argument in an infix (binary) operator,
   *                    represents the node at the root of the parse tree of the first argument
   * @param  parenLevel a List containing the as-yet unclosed parentheses at this level
   * @return            a tuple containing:
   *                      1. a list of tokens remaining after parsing this expression
   *                      2. the root node of the parse tree generated by this expression
   *                      3. a list of the parenthesis depth after parsing this expression
   */
  @tailrec
  private def parseTerm(tokens: List[Token],
                        leftRootIn: ParseNode,
                        parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) = {

    val (tokensAfterLeft, leftRoot, newParenLevelLeft) =
      if (leftRootIn.isEmpty) parseFactor(tokens, leftRootIn, parenLevel)
      else (tokens, leftRootIn, parenLevel)

    if (tokensAfterLeft.isEmpty) (tokensAfterLeft, leftRoot, newParenLevelLeft)
    else {
      val t = tokensAfterLeft.head
      if (t == PLUS || t == DASH) {
        val (tokensAfterRight, rightRoot, newParenLevelRight) =
          parseFactor(tokensAfterLeft.tail, EmptyNode(), newParenLevelLeft)
        parseTerm(tokensAfterRight, TermNode(t, leftRoot, rightRoot), newParenLevelRight)
      } else (tokensAfterLeft, leftRoot, newParenLevelLeft)
    }
  }

  /**
   * Parses a factor (product or quotient) expression, including left associativity
   *
   * @param  tokens     tokens remaining to be parsed in this expression
   * @param  leftRootIn if this expression is the second argument in an infix (binary) operator,
   *                    represents the node at the root of the parse tree of the first argument
   * @param  parenLevel a List containing the as-yet unclosed parentheses at this level
   * @return            a tuple containing:
   *                      1. a list of tokens remaining after parsing this expression
   *                      2. the root node of the parse tree generated by this expression
   *                      3. a list of the parenthesis depth after parsing this expression
   */
  @tailrec
  private def parseFactor(tokens: List[Token],
                          leftRootIn: ParseNode,
                          parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) = {

    val (tokensAfterLeft, leftRoot, newParenLevelLeft) =
      if (leftRootIn.isEmpty) parseSign(tokens, parenLevel)
      else (tokens, leftRootIn, parenLevel)

    if (tokensAfterLeft.isEmpty) (tokensAfterLeft, leftRoot, newParenLevelLeft)
    else {
      val t = tokensAfterLeft.head
      if (t == STAR || t == SLASH) {
        val (tokensAfterRight, rightRoot, newParenLevelRight) =
          parseSign(tokensAfterLeft.tail, newParenLevelLeft)
        parseFactor(tokensAfterRight, FactorNode(t, leftRoot, rightRoot), newParenLevelRight)
      } else (tokensAfterLeft, leftRoot, newParenLevelLeft)
    }
  }

  /**
   * Parses unary (sign) expression, including right associativity
   *
   * @param  tokens     tokens remaining to be parsed in this expression
   * @param  parenLevel a List containing the as-yet unclosed parentheses at this level
   * @return            a tuple containing:
   *                      1. a list of tokens remaining after parsing this expression
   *                      2. the root node of the parse tree generated by this expression
   *                      3. a list of the parenthesis depth after parsing this expression
   */
  private def parseSign(tokens: List[Token], parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) = {
    tokens match {
      case Nil => throw new ParserException("expression terminated where a value was expected")
      case DASH :: rest =>
        val (remainingTokens, number, newParenLevel) = parseSign(rest, parenLevel)
        (remainingTokens, SignNode(DASH, number), newParenLevel)
      case _ => parseNumber(tokens, parenLevel)
    }
  }

  /**
   * Parses a number token or expression into either a numeric terminal node or a nested parse tree
   *
   * @param  tokens          tokens remaining to be parsed in this expression
   * @param  parenLevel      a List containing the as-yet unclosed parentheses at this level
   * @return                 a tuple containing:
   *                           1. a list of tokens remaining after parsing this expression
   *                           2. the root node of the parse tree generated by this expression
   *                           3. a list of the parenthesis depth after parsing this expression
   * @throws ParserException if an infinite value (infinity or divide by zero) is obtained
   * @throws ParserException if an unexpected token is found where a number or parenthesized expression should be
   */
  private def parseNumber(tokens: List[Token], parenLevel: List[Token]): (List[Token], ParseNode, List[Token]) = {
    tokens match {
      case Nil => throw new ParserException("expression terminated where a value was expected")
      case NUMBER(string) :: rest =>
        val value = string.toDouble
        if (value.isInfinite) throw new ParserException("infinite value obtained")
        else (rest, NumberNode(string.toDouble), parenLevel)
      case LPAREN :: rest => parseExpression(rest, EmptyNode(), LPAREN +: parenLevel)
      case _ => throw new ParserException(s"found `${tokens.head.string}` where a value was expected")
    }
  }
}

